{"version":3,"file":"content.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://auto-translate-gpt-extension/./src/content.ts"],"sourcesContent":["\"use strict\";\nconst batchSize = 4;\nconst preferredLanguage = navigator.language.split('-')[0];\nlet detectedLanguage = '';\nif (document.readyState !== 'loading') {\n    setTimeout(() => startTranslation()); // specify batch size\n}\nelse {\n    document.addEventListener('DOMContentLoaded', function () {\n        setTimeout(() => startTranslation()); // specify batch size\n    });\n}\nasync function startTranslation() {\n    const sampleText = document.body.innerText;\n    detectedLanguage = await getLang(sampleText);\n    if (detectedLanguage === preferredLanguage) {\n        console.log(\"Skipping translation, not needed\");\n        return;\n    }\n    const autoTranslate = await shouldAutoTranslate(detectedLanguage);\n    if (autoTranslate) {\n        translateDocument(batchSize);\n    }\n    else {\n        console.log(\"showing popup\", autoTranslate);\n        createTranslationDialog();\n    }\n}\nfunction watchForMutation() {\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            if (mutation.type === 'childList') {\n                mutation.addedNodes.forEach((node) => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        gatherTextNodes(node).then(changedTextNodes => {\n                            console.log(\"Making \" + changedTextNodes.length / batchSize + \" total requests\");\n                            translateInBatches(changedTextNodes, batchSize);\n                        });\n                    }\n                });\n            }\n        });\n    });\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n    });\n}\nfunction translateDocument(batchSize) {\n    console.log(\"Harvesting text\");\n    gatherTextNodes(document.body).then(allTextNodes => {\n        console.log(\"Making \" + allTextNodes.length / batchSize + \" total requests\");\n        translateInBatches(allTextNodes, batchSize);\n    });\n    watchForMutation();\n}\nasync function gatherTextNodes(element) {\n    const allTextNodes = [];\n    const childNodes = Array.from(element.childNodes);\n    for (let node of childNodes) {\n        if (node.nodeType === Node.TEXT_NODE && node.textContent && node.textContent.trim().length > 0) {\n            const detectedLanguage = await getLang(node.textContent);\n            if (detectedLanguage !== preferredLanguage) {\n                allTextNodes.push(node);\n            }\n        }\n        else if (node.nodeType === Node.ELEMENT_NODE) {\n            const childTextNodes = await gatherTextNodes(node);\n            allTextNodes.push(...childTextNodes);\n        }\n    }\n    return allTextNodes;\n}\nfunction translateInBatches(textNodes, batchSize) {\n    for (let i = 0; i < textNodes.length; i += batchSize) {\n        const batch = textNodes.slice(i, i + batchSize);\n        const textArray = batch.map(node => { var _a; return (_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim(); });\n        chrome.runtime.sendMessage({ action: \"translate\", text: textArray }, function (response) {\n            if (response.translatedText && Array.isArray(response.translatedText) && response.translatedText.length === batch.length) {\n                batch.forEach((node, index) => {\n                    if (document.contains(node.parentElement)) {\n                        node.textContent = response.translatedText[index];\n                    }\n                });\n            }\n        });\n    }\n}\nasync function getLang(text) {\n    var _a, _b;\n    const langResult = await chrome.i18n.detectLanguage(text);\n    return (_b = (_a = langResult.languages[0]) === null || _a === void 0 ? void 0 : _a.language) !== null && _b !== void 0 ? _b : \"\";\n}\nfunction shouldAutoTranslate(lang) {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get('alwaysTranslateLanguages', function (data) {\n            const alwaysTranslateLanguages = data.alwaysTranslateLanguages || [];\n            resolve(alwaysTranslateLanguages.includes(lang));\n        });\n    });\n}\nchrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n    if (request.action === 'getDetectedLanguage') {\n        sendResponse({ detectedLanguage: detectedLanguage });\n    }\n    else if (request.action === 'startTranslation') {\n        const alwaysTranslate = request.alwaysTranslate;\n        if (alwaysTranslate) {\n            chrome.storage.sync.get('alwaysTranslateLanguages', function (data) {\n                const alwaysTranslateLanguages = data.alwaysTranslateLanguages || [];\n                if (!alwaysTranslateLanguages.includes(detectedLanguage)) {\n                    alwaysTranslateLanguages.push(detectedLanguage);\n                    chrome.storage.sync.set({ alwaysTranslateLanguages: alwaysTranslateLanguages });\n                }\n            });\n        }\n        translateDocument(batchSize);\n    }\n});\nfunction createTranslationDialog() {\n    const dialog = document.createElement('dialog');\n    dialog.id = 'translation-dialog';\n    dialog.style.position = 'fixed';\n    dialog.style.marginLeft = 'auto';\n    dialog.style.marginRight = '20vw';\n    dialog.style.marginBottom = 'auto';\n    dialog.style.marginTop = '0';\n    dialog.style.padding = '10px';\n    dialog.style.border = '1px solid #ccc';\n    dialog.style.zIndex = '9999';\n    dialog.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.3)';\n    dialog.style.borderRadius = '4px';\n    // Load content into the dialog from ../public/popup.html\n    fetch(chrome.runtime.getURL('../public/popup.html'))\n        .then(response => response.text())\n        .then(html => {\n        console.log(\"erroring out?\");\n        dialog.innerHTML = html;\n        const detectedLanguageNode = dialog.querySelector('#detected-language');\n        const translateButton = dialog.querySelector('#translate-btn');\n        const cancelButton = dialog.querySelector('#cancel-btn');\n        const alwaysTranslateCheckbox = dialog.querySelector('#always-translate-checkbox');\n        if (detectedLanguageNode) {\n            detectedLanguageNode.innerText = detectedLanguage;\n        }\n        translateButton === null || translateButton === void 0 ? void 0 : translateButton.addEventListener('click', function () {\n            const alwaysTranslate = alwaysTranslateCheckbox.checked;\n            if (alwaysTranslate) {\n                chrome.storage.sync.get('alwaysTranslateLanguages', function (data) {\n                    const alwaysTranslateLanguages = data.alwaysTranslateLanguages || [];\n                    if (!alwaysTranslateLanguages.includes(detectedLanguage)) {\n                        alwaysTranslateLanguages.push(detectedLanguage);\n                        chrome.storage.sync.set({ alwaysTranslateLanguages: alwaysTranslateLanguages });\n                    }\n                });\n            }\n            translateDocument(batchSize);\n            dialog.remove();\n        });\n        cancelButton === null || cancelButton === void 0 ? void 0 : cancelButton.addEventListener('click', function () {\n            dialog.remove();\n        });\n        console.log(\"appending to body\");\n        // Append the dialog to the document body\n        document.body.appendChild(dialog);\n        dialog.showModal();\n    })\n        .catch(error => {\n        console.error('Error loading popup.html:', error);\n    });\n}\n"],"names":[],"sourceRoot":""}